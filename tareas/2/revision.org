* De gatos y ratones

** Alfredo Correa
- Documentaci√≥n :: [[./CorreaAlfredo/informacion.txt][informacion.txt]]
- Archivos :: [[./CorreaAlfredo/deGatosYRatones.py][deGatosYRatones.py]]
- Problema desarrollado :: De gatos y ratones
- C√≥digo funcional :: ‚úì
- Comentarios ::
  - Me parece curioso c√≥mo manejas el caso de un gato se coma a un
    rat√≥n, en el primer =if= de =raton()=.
    - Si se comen al primer rat√≥n, s√≥lo disminuyes en 1 tanto a
      =ratonesComiendo= como a =numeroDeRatones=, pero el rat√≥n sigue
      comiendo.
    - S√≥lo cuando =numeroDeRatones == 0= metes un =sleep(10000)= ‚Äî ¬°y
      ojo! ¬°Apenas despu√©s de los 10000 segundos liberas el mutex!
    - (¬øpor qu√© no salir del hilo? ¬øQue c√≥mo sales? =return()= es tu
      respuesta m√°s directa)
  - Obtienes a ambos mutexes, =mutex_hambreRaton= y
    =mutex_hambreGato=, durante el tiempo completo √∫til del
    =while=. Esto lleva a la inanici√≥n (¬°literal!): Puedes tener
    cientos de platos, pero s√≥lo utilizar√°s un m√°ximo de 2 a la vez
    (en caso de que haya un gato y un rat√≥n comiendo al mismo tiempo).
    - Probablemente convendr√≠a obtener el mutex en cuesti√≥n al
      manipular las variables contador, liberarlo, y despu√©s comer...
    - Tambi√©n: En tu modelado, el tiempo que te toma comer de un plato
      es de pr√°cticamente 0 (imprimes =comienza a comer=, aumenas
      =gatosComiendo= o =ratonesComiendo=, y de inmediato =termin√≥ de
      comer=). ¬°No da espacio para un /juego/ divertido! üòâ
- Calificaci√≥n :: 8

* El cruce del r√≠o

** Aldo Abad, Andr√© Rosales
- Documentaci√≥n :: [[./AbadAldo-RosalesAndr√©/reporte escrito.pdf][reporte escrito.pdf]]
- Archivos :: [[./AbadAldo-RosalesAndr√©/problema_bote.py][problema_bote.py]]
- Problema desarrollado :: El cruce del r√≠o
- C√≥digo funcional :: ‚úó
- Comentarios ::
  - ¬°Ojo con la ortograf√≠a! Una balsa puede *zarpar*... pero no s√© qu√©
    sea /sarpar/
  - ¬°Muy bien por probar con el uso de las variables de condici√≥n! Sin
    embargo, as√≠ como lo presentan no funcionar√≠a
    - Recuerden que una variable de condici√≥n tiene que /esperar con
      un mutex/: Tendr√≠an que hacer =listosParaPartir.wait(mutex)=.
  - Como bien indican, en Python no existe =Barrier.signal()=,
    pero... ¬øY para qu√© lo necesitan? Si utilizan barreras, ya tienen
    certeza de que van a entrar en grupos de 2. ¬øSer√° que lo que
    estaban buscando... no es una barrera? ‚ò∫
    - Si tienes una barrera en la cual hay alg√∫n hilo esperando y le
      das =reset()=, tienes que manejar la excepci√≥n
      =threading.BrokenBarrierError= en cada uno de los hilos afectados.
  - La raz√≥n por la que el c√≥digo no avanza m√°s all√° del /hacker/ #0 y
    el /serf/ #0 es que ambas funciones inician obteniendo un mutex
    (=llega_hacker= y =llega_serf=) que no sueltan hasta haberse
    sentado c√≥modamente en la balsa, evaluado la situaci√≥n, y
    posiblemente iniciado el viaje
    - Sencillamente no puede entrar el segundo de ninguno ‚òπ
- Calificaci√≥n :: 7

** Flores Alem√°n, Brenda P√©rez
- Documentaci√≥n :: [[./Alem√°nFlores_P√©rezBrenda/EjercicioBalsa.txt][EjercicioBalsa.txt]]
- Archivos :: [[./Alem√°nFlores_P√©rezBrenda/EjercicioBalsa.py][EjercicioBalsa.py]]
- Problema desarrollado :: El cruce del r√≠o
- C√≥digo funcional :: ‚úì
- Comentarios ::
  - ¬°Nunca hab√≠a visto este enfoque al resolver este problema! Deja
    que todos suban, y si quedan 3/1, la balsa los /retacha/
    - Aunque en realidad... No se /comunica de vuelta/ la decisi√≥n de
      retacharlos a cada uno de los que son bajados, s√≥lo se dej para
      la siguiente vuelta
  - Pero me parece que cumple satisfactoriamente con el
    planteamiento.
- Calificaci√≥n :: 10

** Alejandro Barreiro, Zepeda Jessica
- Documentaci√≥n :: [[./BarreiroAlejandro-JessicaZepeda/tarea2_Barreiro_Zepeda.txt][tarea2_Barreiro_Zepeda.txt]]
- Archivos :: [[./BarreiroAlejandro-JessicaZepeda/cruce_rio_Barreiro_Zepeda.py][cruce_rio_Barreiro_Zepeda.py]]
- Problema desarrollado :: El cruce del r√≠o
- C√≥digo funcional :: ‚úì
- Comentarios ::
  - ¬°Muy bien! Una implementaci√≥n diferente de lo que veo habitualmente
  - Se me hizo raro el comportamiento en que obligan a esperar a que
    lleguen m√∫ltiplos de cuatro personas, para ir intentando la
    asignaci√≥n, como lo mencionan al final del texto ‚Äî pero es
    completamente valido.
  - Mencionan que a veces el sistema reporta al mismo n√∫mero de balsa
    dos veces. ¬°Es el caso exacto en que hay que meter un mutex!
    - Si generan un =balsa_num_mutex=threading.Semaphore(1)=, y en
      =navegar()= hacen la impresi√≥n y suma dentro de un =with
      balsa_num_mutex:=, protegen a =balsa_num= de accesos
      concurrentes.
  - Respecto a la duda de si es un mutex u otro patr√≥n: Me parece que
    el uso de =mutex= no tiene ning√∫n efecto. Si est√° inicializado con
    1, y se libera (=release()=) siempre antes de obtenerlo
    (=acquire()=), y √∫nicamente se adquiere cuando se trata del
    =lider=... Creo que nunca llega a ser menor a 0 (y es como si no
    estuviera ah√≠).
- Calificaci√≥n :: 9

** Jesus Davila y Giselle Espinosa
- Documentaci√≥n :: [[./DavilaJesusyEspinosaGiselle/DavilaJesusyEspinosaGiselle.txt][DavilaJesusyEspinosaGiselle.txt]]
- Archivos :: [[./DavilaJesusyEspinosaGiselle/El_Cruce_del_Rio.py][El_Cruce_del_Rio.py]]
- Problema desarrollado :: El cruce del r√≠o
- C√≥digo funcional :: ‚úì
- Comentarios ::
  - Cuando vi que inicializaban =num_hackers= y =num_serfs= a 5, cre√≠
    que el programa terminar√≠a r√°pido... ¬°Pero no! Ambos quedan en un
    =while True= üòâ
    - El planteamiento del problema habla de cruzar /en un sentido/,
      ¬°recuerden la importancia de ce√±irse a implementar lo que piden
      los requisitos!
  - Implementaci√≥n corta y clara. ¬°Bien!
    - Me parece que emplearon algunas construcciones de m√°s, como
      tener tanto =barr_barca= como =barr_inicia= para controlar a fin
      de cuentas la misma acci√≥n... Pero no /estorba/ üòâ
- Calificaci√≥n :: 10

** Lucero De La Cruz y Emilio Pi√±a
- Archivos :: [[./DeLaCruzLuceroPi√±aEmilio/tarea2.py][tarea2.py]]
- Problema desarrollado :: El cruce del r√≠o
- C√≥digo funcional :: 
- Comentarios ::
- Calificaci√≥n :: 

** Axel Escalona
- Documentaci√≥n :: [[./EscalonaAxel/README.md][README.md]]
- Archivos :: [[./EscalonaAxel/rio.py][rio.py]]
- Problema desarrollado :: El cruce del r√≠o
- C√≥digo funcional :: 
- Comentarios ::
- Calificaci√≥n :: 

* El elevador

** Francisco Barrios
- Archivos :: [[./BarriosFrancisco/elevador.py][elevador.py]]
- Problema desarrollado :: Elevador
- C√≥digo funcional :: casi-‚úì
- Comentarios ::
  - Las instrucciones de entrega mencionan expl√≠citamente que debes
    incluir un archivo de texto con varios puntos ‚òπ
  - Tu program emplea sintaxis obsoleta (Python 2), como la llamada a
    =print= sin par√©ntesis. Te sugiero fuertemente adoptar una versi√≥n
    utilizada actualmente.
  - Como te lo coment√© en la consulta previa, considero importante que
    no s√≥lo utilices mecanismos de sincronizaci√≥n entre las diferentes
    =persona()=, sino que tambi√©n entre en juego la =caja()= del elevador
    - ¬øQu√© pasa si la =caja()= se comienza a mover a otro piso cuando
      una =persona()= decide subir a ella?
    - ¬øQu√© le impone un ritmo m√°ximo de /rebote/ al elevador? En tu
      versi√≥n, sube y baja a toda velocidad por todos los pisos de la
      Facultad. ¬°Estoy seguro de que Protecci√≥n Civil tendr√° algo que
      decir al respecto! ‚òπ
  - ¬øCu√°l es la funci√≥n del =torniquete= al inicio del =while True= de
    =persona()=? Como platicamos, el =torniquete= funciona
    particularmente cuando hay alg√∫n mecanismo de control ‚Äî algo que
    ayude a determinar si se mantiene abierto o cerrado.
  - Tu soluci√≥n cae en un antipatr√≥n que... si bien no es espera
    activa, se le parece /demasiado/:
    #+begin_src python
      while piso_actul != piso_de_persona:
        time.sleep(0.01)
    #+end_src
    - El mecanismo correcto ser√≠a que la =caja()= enviara un mensaje
      (se√±alizaci√≥n) a las =persona()= que estuvieran formadas en las
      diferentes colas por piso.
- Calificaci√≥n :: 7

* Los alumnos y el asesor

** Yoav Galdamez, Ricardo Ruelas
- Documentaci√≥n :: [[./GaldamezYoav-RuelasRicardo/Documentacion.txt][Documentacion.txt]]
- Archivos :: [[./GaldamezYoav-RuelasRicardo/Alumnos_Asesor.py][Alumnos_Asesor.py]]
- Problema desarrollado :: Los alumnos y el asesor
- C√≥digo funcional :: ‚úó
- Comentarios ::
  - En tu implementaci√≥n, todas las preguntas comienzan s√≠-o-s√≠ por
    despertar al asesor
    - En el planteamiento dice que se va a dormir /cuando no hay
      alumnos por atender/. Pero si hay un alumno con varias dudas, tu
      asesor se va a quedar dormido entre pregunta y pregunta.
  - No entiendo el uso doble de tu sem√°foro =responder=. Por un lado,
    lo usas como un torniquete (pero mencionas como comentario
    "Enviamos la se√±al..."), y por otro lado, lo usas para que el
    alumno le diga al profesor que todav√≠a =dudas!=0=.
    - Cuando un alumno trae varias dudas, no vuele a mandar
      =despertar_asesor=, as√≠ que queda en bloqueo mutuo.
  - Al iniciar cada ciclo en =alumno()= obtienes =cubiculoProfesor=,
    =mutex_alumnos= y =alumnos=. ¬øSeguro que vas a anidar /tres/
    regiones de exclusi√≥n mutua una dentro de la otra?
  - El programa no funciona, porque al iniciar esperas por varios
    sem√°foros que inicializaste en cero. Si modifico
    =alumnos=threading.Semaphore(1)= veo que me manda un error porque
    intentas imprimir cu√°ntos alumnos hay en el cub√≠culo, usando
    =len(alumnos)=... Pero =alumnos= es un sem√°foro, ¬°no una lista
    que pueda ser impresa!
- Calificaci√≥n :: 6

* El servidor Web

** Christian Leyva
- Documentaci√≥n :: [[./LeyvaChristian/README.md][README.md]]
- Archivos :: [[./LeyvaChristian/servidor_web.py][servidor_web.py]]
- Problema desarrollado :: El servidor Web
- C√≥digo funcional :: ‚úì
- Comentarios ::
  - Me parece muy bien resuelto. ¬°Bien!
  - J√©, nom√°s me llam√≥ la atenci√≥n ‚Äî un servidor Web normalmente va
    atendiendo (/sirviendo/) diferentes recursos (archivos,
    documentos, o /verbos/ y acciones) locales, no sitios remotos como
    los que conforman a =nombre_paginas=
    - Pero no importa, son s√≥lo etiquetas üòâ
  - Respecto al refinamiento: Para poder llevar informaci√≥n de
    contabilidad, los =Trabajador()= tendr√≠an que notificar al
    =Jefe()= qu√© p√°gina entregaron y cu√°nto tiempo les tom√≥, para que
    √©ste llevara la informaci√≥n acumulada. En este caso, s√≥lo est√°s
    reportando a la salida est√°ndar
    - Esto √∫nicamente me da evidencia de que el =Trabajador()= sabe
      qu√© informaci√≥n tiene que cumplir
    - No te doy el refinamiento como cubierto... ¬°pero no te
      preocupes! De todos modos obtienes tu...
- Calificaci√≥n :: 10

** Bryan Velasco
- Documentaci√≥n :: [[./VelascoBryan/Detalles de tarea.txt][Detalles de tarea.txt]]
- Archivos :: [[./VelascoBryan/tarea2.py][tarea2.py]]
- Problema desarrollado :: El servidor Web
- C√≥digo funcional :: ‚úì
- Comentarios ::
  - ¬°Muy bien resuelto!
  - No llegu√© a ver que se activara el refinamiento para el inicio de
    trabajadores nuevos cuando =disponibles<=0=, pero me parece
    correcta y bien pensada.
    - Respecto a lo que dices que te falt√≥, que los trabajadores ya no
      necesarios liberen sus recursos: cuando tienes el
      =mutexDisponibles= al final de =trabajador()=, podr√≠as revisar
      si =disponibles > umbral=, y si hay demasiados trabajadores
      disponibles, irte a tu casa (=return=) en vez de aumentar
      =disponibles=.
- Calificaci√≥n :: 10
